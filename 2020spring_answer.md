## 1
ALU指令共$21.1+1.7+1.4+2.8+4.8+0.4+20.9$
load-store指令共$26.5+10.3$
Jump指令共$0.8$
Conditional branch指令共$9.3$
做一个加权平均即可。这里认为load和store是load-store指令，cond branch是条件分支指令，jump是无条件跳转指令，其它均为ALU指令。

## 2
### (1)
支持变长，RICS-V除32位外，还有16位的压缩指令集和64位及更高的扩展指令集。基础指令集是定长的。
### (2)
位置有关代码，即指令中使用了绝对地址的代码，如lw和sw指令，它们默认是基址寻址，如果寄存器中的值是固定值，那么这段代码就是位置有关的。在RISC-V指令集中加入了auipc指令，可以容易地在访存指令中相对当前PC寻址，从而实现位置无关。

## 3
下面多的4个周期是流水线填充时间。
### (1)
需要n+4个周期。CPI为$\frac{n+4}{n}$。
### (2)
若没有定向能力，则有60\%的指令需要在前面插入3个气泡，有20\%的指令需要在前面插入2个气泡，可以看作执行了$n+0.6*3n+0.2*2n=3.2n$条指令。CPI为$\frac{3.2n+4}{n}$，当n很大时为3.2。
### (3)
即有0.4\*0.6的指令需要停顿一周期。一共需要$n+0.4*0.6n+4$周期，CPI为$\frac{n+0.4*0.6n+4}{n}$，当n很大时为1.24。

## 4
### (1)
- RAW：指令需要等待操作数均就绪才能执行，指令计算出结果后直接通过CDB传递给需要的RS。
- WAR：通过寄存器重命名。由于指令的操作数可以直接来源于对应的RS，因此是否先写入寄存器对指令的执行没有影响。
- WAW：在RegisterStat中记录了每个寄存器的结果来源，对于写入同一个寄存器的指令，后发射的指令会在RegisterStat中覆盖前一条指令所写的来源，因此不会出现问题。
### (2)
精确中断即发生中断时保证当前指令之前的指令均已执行完，之后的指令还没执行。对于Tomasulo，要实现精确中断需要使用ROB，通过ROB保证顺序写回，在发生中断时让前面的指令完成到寄存器的写入，并冲刷后面的指令。

## 5
|instruction|i|j|k|Issue|Read operand|Execution complete|Write result|
|-|-|-|-|-|-|-|-|
|LD|F6|34+|R2|1|2|3|4|
|LD|F2|45+|R3|5|6|7|8|
|MULT|F0|F2|F4|6|9|15|16|
|SUBD|F8|F6|F2|7|9|11|12|
|DIVD|F10|F0|F6|8|17|47|48|
|ADDD|F6|F8|F2|13|14|16|17|

## 6
题目描述的不是很清楚，我理解为每次访存都要多一个周期，即全部命中情况下的CPI为1+1.4=2.4周期。
### (1)
#### 对于直接相联Cache：
失效开销为$65/0.35=186$周期（向上取整）
CPI为：$1+1.4*1+2.1\%*186=6.306$，每条指令执行所需时间为2.2071ns
#### 对于组相联Cache：
时钟周期变为$0.35*1.35=0.47ns$
失效开销为$65/0.47=139$周期
CPI为$1+1.4+1.9\%*139=5.041$周期，每条指令执行时间为2.36927ns

## 7
认为1K=1024.
### (1)
共256个warp，每个sm执行32个warp。
### (2)
指令级并行（？）
### (3)
是SIMT。

## 8
### (1)
未采用链接共5个convoy，$T_{chime}$为5。
（由于向量长度为64，是不是也可以理解为有20个chime？）
### (2)
采用链接技术后共3个convoy，假设一个convoy的启动开销取其中几条指令的启动开销的最大值，则启动开销共24周期，总共需要$4*(24+10)+200*3=736$周期。平均一个结果3.68周期
### (3)
这种情况下只需一个convoy，启动开销8个周期，总共需要$4*(8+10)+200=272$周期。平均一个结果1.36周期。

## 9
### (1)
|Action|Bus activity|P0\$|P1\$|Mem[x]|
|-|-|-|-|-|
|||--|--|0|
|P0 load x|BusRd|0|--|0|
|P1 load x|BusRd|0|0|0|
|P0 write 200 to x|BusWr|200|--|200|
|P1 load x|BusRd|200|200|200|
### (2)
- 写作废
  - 优点：写入时无需向其他所有处理器广播写入的值，只需在写入前进行一次作废操作即可。
  - 缺点：多个处理器频繁对同一个块进行写入和读取时，会频繁作废，降低性能。
- 写更新：
  - 优点：从一个处理器写入到令一个处理器读取的延迟通常较短。
  - 缺点：单个处理器长时间对同一个位置写入时需要频繁更新其他处理器的Cache，降低性能。

## 10
这里B的初始值应该为1吧，否则结果很奇怪
这一块都不是很懂
### (1)
输出为1 0。
### (2)
Thread2可能会抢在Thread1将A置1前执行，从而导致输出两个0.